import java.util.*;

public class P61_CyclicalFigurateNumbers {
    // Project Euler - Problem 61 - Cyclical figurate numbers
    // Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal)
    // numbers and are generated by the following formulae:
    // Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
    // Square	 	P4,n=n2	 	        1, 4, 9, 16, 25, ...
    // Pentagonal	P5,n=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
    // Hexagonal	P6,n=n(2n−1)	 	1, 6, 15, 28, 45, ...
    // Heptagonal	P7,n=n(5n−3)/2	 	1, 7, 18, 34, 55, ...
    // Octagonal	P8,n=n(3n−2)	 	1, 8, 21, 40, 65, ...
    // The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
    // The set is cyclic, in that the last two digits of each number is the first two digits of the next number
    // (including the last number with the first).
    // Each polygonal type: triangle P(3,127)=8128, square P(4,91)=8281, and pentagonal P(5,44)=2882, is
    // represented by a different number in the set.
    // This is the only set of 4-digit numbers with this property.
    // Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type:
    // triangle, square, pentagonal, hexagonal, heptagonal, and octagonal,
    // is represented by a different number in the set.

    public static void main(String[] args) {
        diagnosticsToStdOut = false;
        String message = "The sum of the only ordered set of six cyclic 4-digit numbers " +
                "for which each polygonal type: " +
                "triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, " +
                "is represented by a different number in the set is %,d\n" +
                "The set is: %s\n";
        List<String> solution = P61_CyclicalFigurateNumbers.find(6);
        long sum = getSum(solution);
        System.out.printf(message, sum, solution.toString());
    }

    private static final int MIN_ORDER = 3;
    private static final int MAX_ORDER = 8;
    private static final int LENGTH = 4;
    private static boolean diagnosticsToStdOut = false;
    private static TreeMap<String, List<String>> polygonals;

    static List<String> find(int size) {
        return find(size, size, 0, 0);
    }

    private static List<String> find(int solutionSize, int size, int seed, int offset) {
        if (polygonals == null) buildPolygonals();
        if (size == 1) return makeList(seed, offset);
        List solution = new ArrayList();
        List partial = find(solutionSize, size - 1, seed, offset);
//        while (true) {
//
//        }
        return solution;
    }

    private static void buildPolygonals() {
        polygonals = new TreeMap<>();
        int[] polygonal = getStart();
        int count = 0;
        while (true) {
            if (isUnderflow(polygonal)) break;
            if (!isWrongSize(polygonal)) {
                System.out.println("polygonal = " + Arrays.toString(polygonal));
                count++;
                addPolygonal(polygonal);
            }
            polygonal = getNext(polygonal);
        }
        showListCheck(count);
    }

    private static void addPolygonal(int[] polygonal) {
        String key = getHead(polygonal);
        String value = getTail(polygonal);
        List<String> list = polygonals.get(key);
        if (list == null) {
            list = new ArrayList<>();
            polygonals.put(key, list);
        }
        list.add(value);
    }

    private static List<String> makeList(int seed, int offset) {
        List<String> list = new ArrayList<>();
        String chunk = polygonals.firstKey();
        for (int i = 0; i < seed; i++) chunk = polygonals.higherKey(chunk);
        list.add(chunk);
        list.add(polygonals.get(chunk).get(offset));
        return list;
    }

    static long getSum(List<String> list) {
        if (list.size() < 1) return 0;
        long sum = 0;
        int last = Integer.valueOf(list.get(0));
        for (int i = 1, listSize = list.size(); i < listSize; i++) {
            sum += last * 100;
            last = Integer.valueOf(list.get(i));
            sum += last;
        }
        return sum;
    }

    // Solution evaluation:

    static List<int[]> checkSolution(int size, List<int[]> partial, int[] polygonal) {
        partial.add(polygonal);
        if (isSolution(size, partial)) return partial;
        return null;
    }

    static boolean isSolution(int size, List<int[]> list) {
        switch (list.size()) {
            case 0:
                return true;
            case 1:
                return CyclicPolygonal.getDigitCount(list.get(0)) == LENGTH;
            default:
                return isCyclicSolution(size, list);
        }
    }

    private static boolean isCyclicSolution(int size, List<int[]> list) {
        return CyclicPolygonal.hasRequiredDigitCounts(list, LENGTH) &&
                CyclicPolygonal.hasUniqueOrders(list) &&
                CyclicPolygonal.isCyclicAndWraps(size, list);
    }

    // Diagnostics:

    private static void showCall(int size, int[] seed) {
        if (!diagnosticsToStdOut) return;
        System.out.printf("size: %d, seed: %s, %d\n", size, Arrays.toString(seed), CyclicPolygonal.getValue(seed));
    }

    private static void showStep(int size, int[] seed, int[] anchor, List<int[]> partial) {
        if (!diagnosticsToStdOut) return;
        System.out.printf("size: %d, seed: %s, %,d, anchor: %s, %d\n", size,
                Arrays.toString(seed), CyclicPolygonal.getValue(seed),
                Arrays.toString(anchor), CyclicPolygonal.getValue(anchor));
        showList(partial);
    }

    private static void showListCheck(int count) {
        System.out.println("count = " + count);
        int count2 = 0;
        for (String key : polygonals.keySet()) {
            List<String> value = polygonals.get(key);
            System.out.printf("%s: %s\n", key, value);
            count2 += value.size();
        }
        System.out.println("count2 = " + count2);
    }

    private static void showList(List<int[]> partial) {
        if (!diagnosticsToStdOut) return;
        if (partial != null) {
            for (int i = 0; i < partial.size(); i++) {
                System.out.printf("partial[%d]: %,d\n", i, CyclicPolygonal.getValue(partial.get(i)));
            }
        } else {
            System.out.println("partial: null");
        }
    }

    // CyclicPolygonal wrappers:

    private static String getHead(int[] polygonal) {
        return CyclicPolygonal.getFirstDigits(polygonal, LENGTH / 2);
    }

    private static String getTail(int[] polygonal) {
        return CyclicPolygonal.getLastDigits(polygonal, LENGTH / 2);
    }

    private static int[] getStart() {
        return CyclicPolygonal.getStart(MAX_ORDER);
    }

    private static boolean isUnderflow(int[] polygonal) {
        return CyclicPolygonal.isUnderflow(polygonal, MIN_ORDER);
    }

    private static boolean isWrongSize(int[] polygonal) {
        return CyclicPolygonal.isWrongSize(polygonal, LENGTH);
    }

    private static boolean isTooSmall(int[] polygonal) {
        return CyclicPolygonal.isTooSmall(polygonal, LENGTH);
    }

    private static boolean isTooLarge(int[] polygonal) {
        return CyclicPolygonal.isTooLarge(polygonal, LENGTH);
    }

    private static int[] getNext(int[] polygonal) {
        return CyclicPolygonal.getNext(polygonal, LENGTH);
    }
}
